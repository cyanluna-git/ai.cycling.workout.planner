"""Workout text validator.

This module validates workout text generated by AI to ensure it follows
the Intervals.icu workout text syntax.
"""

import logging
import re
from dataclasses import dataclass
from typing import Optional

logger = logging.getLogger(__name__)


@dataclass
class ValidationResult:
    """Result of workout text validation."""

    is_valid: bool
    errors: list[str]
    warnings: list[str]
    cleaned_text: str


class WorkoutValidator:
    """Validate and clean workout text for Intervals.icu.

    Ensures the AI-generated workout text follows the correct syntax
    and doesn't contain unrealistic training parameters.

    Valid formats:
    - 10m 50% (10 minutes at 50% FTP)
    - 30s 120% (30 seconds at 120% FTP)
    - 5x 3m 115% 3m 50% (5 intervals of 3min at 115%, 3min recovery at 50%)
    - 60m Z2 (60 minutes in Zone 2)

    Example:
        >>> validator = WorkoutValidator()
        >>> result = validator.validate("10m 50%\\n5x 3m 115% 3m 50%\\n10m 50%")
        >>> print(result.is_valid)
        True
    """

    # Maximum power percentages by zone/duration (safety limits)
    MAX_POWER_LIMITS = {
        5: 200,  # Max 200% for 5 seconds
        30: 180,  # Max 180% for 30 seconds
        60: 150,  # Max 150% for 1 minute
        180: 130,  # Max 130% for 3 minutes
        300: 120,  # Max 120% for 5 minutes
        600: 110,  # Max 110% for 10 minutes
        1800: 100,  # Max 100% for 30+ minutes
    }

    # Valid workout step patterns
    PATTERNS = {
        # Duration with power percentage: 10m 50%, 30s 120%
        "duration_power": re.compile(
            r"^(\d+)\s*(s|m|h)\s+(\d+(?:\.\d+)?)\s*%$",
            re.IGNORECASE,
        ),
        # Duration with zone: 10m Z2, 1h z3
        "duration_zone": re.compile(
            r"^(\d+)\s*(s|m|h)\s+[Zz](\d)$",
            re.IGNORECASE,
        ),
        # Intervals: 5x 3m 115% 3m 50%
        "intervals": re.compile(
            r"^(\d+)\s*x\s+(.+)$",
            re.IGNORECASE,
        ),
        # Ramp: ramp 10m 50% to 100%
        "ramp": re.compile(
            r"^ramp\s+(\d+)\s*(s|m|h)\s+(\d+)\s*%\s+to\s+(\d+)\s*%$",
            re.IGNORECASE,
        ),
        # Free ride: 10m free
        "free": re.compile(
            r"^(\d+)\s*(s|m|h)\s+free$",
            re.IGNORECASE,
        ),
    }

    def __init__(self, max_duration_minutes: int = 180):
        """Initialize the validator.

        Args:
            max_duration_minutes: Maximum allowed workout duration (default: 180 min).
        """
        self.max_duration_minutes = max_duration_minutes

    def validate(self, workout_text: str) -> ValidationResult:
        """Validate workout text.

        Args:
            workout_text: The workout text to validate.

        Returns:
            ValidationResult with validation status and cleaned text.
        """
        errors: list[str] = []
        warnings: list[str] = []
        cleaned_lines: list[str] = []

        # Clean and split into lines
        lines = self._clean_text(workout_text)

        if not lines:
            errors.append("Workout text is empty")
            return ValidationResult(
                is_valid=False,
                errors=errors,
                warnings=warnings,
                cleaned_text="",
            )

        total_duration_seconds = 0

        for i, line in enumerate(lines, 1):
            line_result = self._validate_line(line, i)

            if line_result["error"]:
                errors.append(line_result["error"])
            if line_result["warning"]:
                warnings.append(line_result["warning"])
            if line_result["duration"]:
                total_duration_seconds += line_result["duration"]
            if line_result["cleaned"]:
                cleaned_lines.append(line_result["cleaned"])

        # Check total duration
        total_minutes = total_duration_seconds / 60
        if total_minutes > self.max_duration_minutes:
            warnings.append(
                f"Total duration ({total_minutes:.0f}m) exceeds maximum ({self.max_duration_minutes}m)"
            )
        elif total_minutes < 10:
            warnings.append(f"Total duration ({total_minutes:.0f}m) is very short")

        is_valid = len(errors) == 0
        cleaned_text = "\n".join(cleaned_lines)

        if is_valid:
            logger.info(
                f"Workout validated: {len(cleaned_lines)} steps, {total_minutes:.0f} minutes"
            )
        else:
            logger.warning(f"Workout validation failed: {errors}")

        return ValidationResult(
            is_valid=is_valid,
            errors=errors,
            warnings=warnings,
            cleaned_text=cleaned_text,
        )

    def _clean_text(self, text: str) -> list[str]:
        """Clean and split workout text into lines.

        Args:
            text: Raw workout text.

        Returns:
            List of cleaned lines.
        """
        lines = []

        for line in text.strip().split("\n"):
            # Remove leading dashes, bullets, and numbered list markers (1. or 1))
            # But preserve workout text like "10m 50%"
            cleaned = re.sub(
                r"^[\s]*[-\*][\s]*", "", line
            ).strip()  # Remove bullet points
            cleaned = re.sub(
                r"^[\s]*\d+[.)]\s+", "", cleaned
            ).strip()  # Remove numbered lists like "1. " or "1) "
            if cleaned:
                lines.append(cleaned)

        return lines

    def _validate_line(self, line: str, line_number: int) -> dict:
        """Validate a single workout line.

        Args:
            line: Single workout step.
            line_number: Line number for error reporting.

        Returns:
            Dictionary with validation results.
        """
        result = {
            "error": None,
            "warning": None,
            "duration": 0,
            "cleaned": None,
        }

        # Try each pattern
        for pattern_name, pattern in self.PATTERNS.items():
            match = pattern.match(line)
            if match:
                return self._validate_pattern(pattern_name, match, line, line_number)

        # No pattern matched
        result["error"] = f"Line {line_number}: Invalid format '{line}'"
        return result

    def _validate_pattern(
        self,
        pattern_name: str,
        match: re.Match,
        line: str,
        line_number: int,
    ) -> dict:
        """Validate a matched pattern.

        Args:
            pattern_name: Name of the matched pattern.
            match: Regex match object.
            line: Original line.
            line_number: Line number for error reporting.

        Returns:
            Dictionary with validation results.
        """
        result = {
            "error": None,
            "warning": None,
            "duration": 0,
            "cleaned": line,
        }

        if pattern_name == "duration_power":
            duration = self._parse_duration(match.group(1), match.group(2))
            power = float(match.group(3))

            result["duration"] = duration

            # Check power limit for duration
            warning = self._check_power_limit(duration, power)
            if warning:
                result["warning"] = f"Line {line_number}: {warning}"

        elif pattern_name == "duration_zone":
            duration = self._parse_duration(match.group(1), match.group(2))
            result["duration"] = duration

        elif pattern_name == "intervals":
            reps = int(match.group(1))
            interval_text = match.group(2)

            # Parse interval parts (simplified)
            parts = interval_text.split()
            if len(parts) >= 2:
                # Estimate duration (very simplified)
                for i, part in enumerate(parts):
                    if part.endswith("m") or part.endswith("s"):
                        dur = self._parse_duration(part[:-1], part[-1])
                        result["duration"] += dur * reps

        elif pattern_name == "ramp":
            duration = self._parse_duration(match.group(1), match.group(2))
            result["duration"] = duration

        elif pattern_name == "free":
            duration = self._parse_duration(match.group(1), match.group(2))
            result["duration"] = duration

        return result

    def _parse_duration(self, value: str, unit: str) -> int:
        """Parse duration to seconds.

        Args:
            value: Numeric duration value.
            unit: Duration unit (s, m, h).

        Returns:
            Duration in seconds.
        """
        num = int(value)
        unit = unit.lower()

        if unit == "s":
            return num
        elif unit == "m":
            return num * 60
        elif unit == "h":
            return num * 3600
        return 0

    def _check_power_limit(
        self, duration_seconds: int, power_percent: float
    ) -> Optional[str]:
        """Check if power is within safe limits for the duration.

        Args:
            duration_seconds: Duration in seconds.
            power_percent: Power as percentage of FTP.

        Returns:
            Warning message if limit exceeded, None otherwise.
        """
        for limit_duration, max_power in sorted(self.MAX_POWER_LIMITS.items()):
            if duration_seconds <= limit_duration:
                if power_percent > max_power:
                    return f"{power_percent}% for {duration_seconds}s exceeds safe limit ({max_power}%)"
                return None

        # Check longest duration limit
        if power_percent > 100:
            return f"{power_percent}% for {duration_seconds}s is not sustainable"

        return None
