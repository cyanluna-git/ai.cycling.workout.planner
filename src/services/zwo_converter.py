"""ZWO (Zwift Workout) Format Converter.

Converts structured workout steps to ZWO XML format for Intervals.icu upload.
ZWO is a well-documented standard that Intervals.icu natively supports.

ZWO Elements:
- <Warmup> - Ramp from low to high power
- <Cooldown> - Ramp from high to low power
- <SteadyState> - Constant power interval
- <IntervalsT> - Repeated intervals (on/off pattern)
- <FreeRide> - No power target
"""

import base64
import xml.etree.ElementTree as ET
from typing import Any, Dict, List, Union


class ZWOConverter:
    """Convert structured workout steps to ZWO XML format."""

    def __init__(self, workout_name: str = "AI Generated Workout"):
        """Initialize converter.

        Args:
            workout_name: Name of the workout for ZWO metadata.
        """
        self.workout_name = workout_name

    def convert(self, steps: List[Dict[str, Any]]) -> str:
        """Convert workout steps to ZWO XML string.

        Args:
            steps: List of workout step dictionaries from ProtocolBuilder.

        Returns:
            ZWO XML string.
        """
        # Create root element
        root = ET.Element("workout_file")

        # Add metadata
        ET.SubElement(root, "author").text = "AI Workout Planner"
        ET.SubElement(root, "name").text = self.workout_name
        ET.SubElement(root, "description").text = "Generated by AI Workout Planner"
        ET.SubElement(root, "sportType").text = "bike"

        # Create workout element
        workout = ET.SubElement(root, "workout")

        # Convert each step
        for step in steps:
            self._convert_step(workout, step)

        # Convert to string with XML declaration
        return self._to_xml_string(root)

    def convert_to_base64(self, steps: List[Dict[str, Any]]) -> str:
        """Convert workout steps to base64-encoded ZWO XML.

        Args:
            steps: List of workout step dictionaries.

        Returns:
            Base64-encoded ZWO XML string.
        """
        xml_str = self.convert(steps)
        return base64.b64encode(xml_str.encode("utf-8")).decode("utf-8")

    def _convert_step(self, parent: ET.Element, step: Dict[str, Any]) -> None:
        """Convert a single step to ZWO element.

        Args:
            parent: Parent XML element to add step to.
            step: Step dictionary.
        """
        # Check if this is a repetition block
        if "reps" in step and "steps" in step:
            self._add_intervals(parent, step)
            return

        # Check if this is a ramp
        if step.get("ramp"):
            self._add_ramp(parent, step)
            return

        # Default to steady state
        self._add_steady_state(parent, step)

    def _add_ramp(self, parent: ET.Element, step: Dict[str, Any]) -> None:
        """Add a ramp (warmup or cooldown) element.

        ZWO uses PowerLow/PowerHigh as decimal FTP percentages.
        e.g., 75% = 0.75
        """
        power = step.get("power", {})
        start_power = power.get("start", 50) / 100  # Convert % to decimal
        end_power = power.get("end", 75) / 100
        duration = step.get("duration", 600)

        # Determine if warmup or cooldown based on power direction or flags
        if step.get("warmup") or start_power < end_power:
            elem = ET.SubElement(parent, "Warmup")
        elif step.get("cooldown") or start_power > end_power:
            elem = ET.SubElement(parent, "Cooldown")
        else:
            # Generic ramp - treat as warmup if ascending, cooldown if descending
            elem = ET.SubElement(
                parent, "Warmup" if start_power < end_power else "Cooldown"
            )

        elem.set("Duration", str(duration))
        elem.set("PowerLow", f"{start_power:.2f}")
        elem.set("PowerHigh", f"{end_power:.2f}")

    def _add_steady_state(self, parent: ET.Element, step: Dict[str, Any]) -> None:
        """Add a steady state (constant power) element."""
        power = step.get("power", {})
        power_value = power.get("value", 75) / 100  # Convert % to decimal
        duration = step.get("duration", 300)

        elem = ET.SubElement(parent, "SteadyState")
        elem.set("Duration", str(duration))
        elem.set("Power", f"{power_value:.2f}")

    def _add_intervals(self, parent: ET.Element, step: Dict[str, Any]) -> None:
        """Add repeated intervals element.

        ZWO IntervalsT format:
        <IntervalsT Repeat="N" OnDuration="X" OffDuration="Y" OnPower="A" OffPower="B"/>
        """
        # Support both "reps" and "repeat" keys for compatibility
        reps = step.get("reps") or step.get("repeat", 1)
        inner_steps = step.get("steps", [])

        if len(inner_steps) < 2:
            # Not enough steps for intervals, add as steady states
            for _ in range(reps):
                for s in inner_steps:
                    self._add_steady_state(parent, s)
            return

        # Extract on/off from first two steps
        on_step = inner_steps[0]
        off_step = inner_steps[1]

        on_power = on_step.get("power", {}).get("value", 100) / 100
        off_power = off_step.get("power", {}).get("value", 50) / 100
        on_duration = on_step.get("duration", 30)
        off_duration = off_step.get("duration", 30)

        elem = ET.SubElement(parent, "IntervalsT")
        elem.set("Repeat", str(reps))
        elem.set("OnDuration", str(on_duration))
        elem.set("OffDuration", str(off_duration))
        elem.set("OnPower", f"{on_power:.2f}")
        elem.set("OffPower", f"{off_power:.2f}")

    def _to_xml_string(self, root: ET.Element) -> str:
        """Convert ElementTree to formatted XML string."""
        # Use minidom for pretty printing
        from xml.dom import minidom

        rough_string = ET.tostring(root, encoding="unicode")
        reparsed = minidom.parseString(rough_string)
        return reparsed.toprettyxml(indent="  ")
